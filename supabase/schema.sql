-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- PROFILES (Rol de usuario)
create table if not exists public.profiles (
  id uuid references auth.users not null primary key,
  email text,
  rol text check (rol in ('profesor', 'alumno')) default 'alumno',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- PROYECTOS
create table if not exists public.proyectos (
  id uuid default uuid_generate_v4() primary key,
  nombre text not null,
  descripcion text,
  tipo text, 
  estado text check (estado in ('En curso', 'Finalizado', 'En preparaciÃ³n')),
  codigo_sala text unique,
  clase text, 
  fases jsonb default '[]'::jsonb, 
  created_by uuid references public.profiles(id),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- GRUPOS
create table if not exists public.grupos (
  id bigint generated by default as identity primary key,
  nombre text not null,
  departamento text,
  miembros jsonb default '[]'::jsonb,
  progreso integer default 0,
  estado text check (estado in ('En progreso', 'Casi terminado', 'Completado', 'Bloqueado')),
  interacciones_ia integer default 0,
  proyecto_id uuid references public.proyectos(id) on delete cascade,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- MENSAJES DE CHAT (Historial IA)
create table if not exists public.mensajes_chat (
  id bigint generated by default as identity primary key,
  grupo_id bigint references public.grupos(id) on delete cascade,
  usuario_id uuid references public.profiles(id),
  tipo text check (tipo in ('user', 'assistant', 'system')),
  contenido text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- ALUMNOS CONECTADOS (Real-time presence)
create table if not exists public.alumnos_conectados (
  id uuid default uuid_generate_v4() primary key,
  proyecto_id uuid references public.proyectos(id) on delete cascade,
  nombre_alumno text not null,
  last_active timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS (Row Level Security) - Policies safe re-run
alter table public.profiles enable row level security;
alter table public.proyectos enable row level security;
alter table public.grupos enable row level security;
alter table public.mensajes_chat enable row level security;
alter table public.alumnos_conectados enable row level security;

DO $$ 
BEGIN
    -- Drop existing policies to avoid conflict
    DROP POLICY IF EXISTS "Public access" ON public.profiles;
    DROP POLICY IF EXISTS "Public access" ON public.proyectos;
    DROP POLICY IF EXISTS "Public access" ON public.grupos;
    DROP POLICY IF EXISTS "Public access" ON public.mensajes_chat;
    DROP POLICY IF EXISTS "Public access" ON public.alumnos_conectados;
END $$;

create policy "Public access" on public.profiles for all using (true);
create policy "Public access" on public.proyectos for all using (true);
create policy "Public access" on public.grupos for all using (true);
create policy "Public access" on public.mensajes_chat for all using (true);
create policy "Public access" on public.alumnos_conectados for all using (true);

-- PROFILES (Rol de usuario)
create table if not exists public.profiles (
  id uuid references auth.users not null primary key,
  email text,
  rol text check (rol in ('profesor', 'alumno')) default 'alumno',
  full_name text, -- Nuevo campo
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- (Rest of tables omitted for brevity, but trigger is key)

-- TRIGGER (Handle gracefully)
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, rol, full_name)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data ->> 'rol', 'alumno'), -- Prioriza metadata, fallback alumno
    coalesce(new.raw_user_meta_data ->> 'nombre', new.raw_user_meta_data ->> 'full_name', new.email)
  )
  on conflict (id) do update
  set 
    rol = excluded.rol,
    full_name = excluded.full_name,
    email = excluded.email;
  return new;
end;
$$ language plpgsql security definer;

-- Drop trigger if exists to avoid error
drop trigger if exists on_auth_user_created on auth.users;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
